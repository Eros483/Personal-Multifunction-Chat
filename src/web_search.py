import os
from typing import List
from serpapi import GoogleSearch
from playwright.sync_api import sync_playwright
from dotenv import load_dotenv
import requests
import json
from prompt_templates.prompt_templates import web_search_prompt_template

load_dotenv()

class WebSearch:
    def __init__(self, user_query: str):
        """
        Initialize the WebSearch class with a user query.
        Args:
            user_query (str): The user's query to search.
        """
        self.user_query = user_query
        self.serper_api_key = os.getenv("SERPER_API_KEY")

    def web_search(self) -> List[str]:
        """
        Perform a web search to answer the query

        Returns:
            list: A list of 4-5 URLs relevant to query.
        """
        print(f"Performing web search for query: {self.user_query}")
        params = {
            "q": self.user_query,
            "api_key": self.serper_api_key,
            "engine": "google",
            "num": 5
        }

        search = GoogleSearch(params)
        results = search.get_dict()
        print("Finished web search, processing results...")
        if "organic_results" in results:
            results = results["organic_results"]
            return [result["link"] for result in results if "link" in result]
        else:
            return []

    def get_url_contents(self, url: str) -> str:
        """
        Get the contents of a URL

        Args:
            url (str): The URL to fetch.
        Returns:
            str: The content of the page at the given URL.
        """
        print("getting URL contents for:", url)
        try:
            with sync_playwright() as p:
                browser = p.chromium.launch(headless=True)
                page = browser.new_page()
                page.goto(url, wait_until="networkidle")

                content = page.evaluate("""
                    () => {
                        // Remove script, style, nav, footer elements
                        const elementsToRemove = document.querySelectorAll('script, style, nav, footer, header, .nav, .footer, .header, .sidebar');
                        elementsToRemove.forEach(el => el.remove());
                        
                        // Get main content area if it exists
                        const mainContent = document.querySelector('main, .main, .content, article, .article, #content, #main') || document.body;
                        
                        return mainContent.innerText.trim();
                    }
                """)
                
                browser.close()
                # Limit content length to avoid overwhelming the model
                if len(content) > 3000:
                    content = content[:3000] + "... [content truncated]"
                return content
            
        except Exception as e:
            print(f"Error fetching content from {url}: {e}")
            return None

    def get_user_query_answer(self) -> str:
        """
        Get the answer to a user query by performing a web search and fetching URL contents.
        
        Returns:
            str: All relevant information.
        """
        print(f"Getting answer for user query: {self.user_query}")
        urls = self.web_search()
        if not urls:
            return "No relevant results found."
        
        information_retrieved=[]
        for url in urls:
            content = self.get_url_contents(url)
            if content:
                information_retrieved.append(content)
        print(f"Retrieved pieces of information from URLs.")
        return "\n\n".join(information_retrieved)

    def process_with_ollama(
        self,
        information: str, 
        model: str = "llama3.1:8b-instruct-q4_K_M",
        prompt_template: str = None,
        ollama_url: str = "http://localhost:11434/api/chat"
        ) -> str:
        """
        Processes retrieved information with Ollama
        Args:
            information (str): The information retrieved from web search.
            model (str): The Ollama model to use.
            prompt_template (str): Optional custom prompt template.
            ollama_url (str): URL of the Ollama server.
        Returns:
            str: The response generated by the Ollama model.
        """
        print("Inside ollama block")
        if prompt_template is None:
            prompt_template = web_search_prompt_template(self.user_query, information)

        formatted_prompt = prompt_template.format(
            information=information,
            query=self.user_query
        )

        payload = {
            "model": model,
            "messages": [
                {"role": "system", "content": "You are a helpful assistant."},
                {"role": "user", "content": formatted_prompt}
            ],
            "stream": False
        }

        try:
            response = requests.post(
                ollama_url,
                json=payload,
                headers={"Content-Type": "application/json"},
                timeout=60
            )
            response.raise_for_status()
            result = response.json()
            return result.get("message", {}).get("content", "No response generated")
        
        except requests.exceptions.RequestException as e:
            return f"Error communicating with Ollama: {str(e)}"
        except json.JSONDecodeError as e:
            return f"Error parsing Ollama response: {str(e)}"
        except Exception as e:
            return f"Unexpected error: {str(e)}"
        
    def run(self) -> str:
        """
        Run the web search and process the information with Ollama.
        
        Returns:
            str: The final response from the agent.
        """
        information = self.get_user_query_answer()
        if "No relevant results found." in information:
            return information
        
        final_response = self.process_with_ollama(information)
        return final_response

if __name__ == "__main__":
    query = input("Enter your query: ")
    agent = WebSearch(query)
    response = agent.run()
    print(response)

    with open("agent_response.txt", "w", encoding="utf-8") as f:
        f.write(response)
